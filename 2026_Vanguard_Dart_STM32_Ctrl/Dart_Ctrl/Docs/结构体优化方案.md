# 结构体优化方案

## 概述

本文档分析当前工程的结构体设计，并提供基于**链表**和**共用体**的优化建议。

---

## 一、CanMotor 电机管理器优化

### 1.1 当前问题

```c
// 当前设计 - 静态数组
typedef struct {
    MotorTypeDef MotorList[g_CanMotorNum];  // 固定大小数组
    uint8_t registered_count;
    uint8_t RM_MOTOR_DATA_ARRAY[8];
} MotorManager_t;
```

**缺点**：
- 电机数量固定，无法动态增减
- RM和DM电机数据结构相同但解算方式不同，缺乏区分
- PID控制器同时存在`speed_pid`和`cascade_pid`，浪费内存

### 1.2 优化方案：链表 + 共用体

```c
/*======================== 优化后的结构体 ========================*/

// 电机品牌特定数据（共用体）
typedef union {
    // RM电机反馈数据
    struct {
        int16_t angle;        // 0-8191
        int16_t speed_rpm;    // rpm
        int16_t torque;       // 电流/力矩
        uint8_t temperature;  // 温度
    } rm;
    
    // DM电机反馈数据
    struct {
        uint16_t position;    // 位置
        int16_t velocity;     // 速度
        int16_t torque;       // 力矩
        uint8_t mos_temp;     // MOS温度
        uint8_t rotor_temp;   // 转子温度
        uint8_t state;        // 状态码
    } dm;
    
    uint8_t raw[8];           // 原始数据
} MotorFeedback_t;

// 解算后的数据（共用体）
typedef union {
    struct {
        float angle;          // 单圈角度
        float speed_rpm;      // 速度(rpm)
        float current;        // 电流(A)
        float total_angle;    // 累计角度
        float speed_rad;      // 速度(rad/s)
    } rm;
    
    struct {
        float position;       // 位置(°)
        float velocity;       // 速度(rad/s)
        float torque;         // 力矩(N·m)
        float mos_temp;       // MOS温度
        float rotor_temp;     // 转子温度
    } dm;
    
    float data[5];            // 统一数组访问
} MotorSolvedData_t;

// PID控制器（共用体，节省内存）
typedef union {
    PID_t single;             // 单环PID
    CASCADE_PID_t cascade;    // 串级PID
} PID_Controller_t;

// 电机链表节点
typedef struct _MotorNode {
    // 基本信息
    uint8_t motor_id;
    uint8_t motor_band;       // RM_MOTOR_BAND / DM_MOTOR_BAND
    
    // 数据存储
    uint8_t tx_data[8];
    MotorFeedback_t feedback;
    MotorSolvedData_t solved;
    
    // CAN配置
    CAN_TxHeaderTypeDef tx_header;
    
    // 控制器
    uint8_t pid_mode;         // 0=单环, 1=串级
    PID_Controller_t pid;
    
    // 函数指针
    uint8_t (*send)(struct _MotorNode *);
    void (*solve)(struct _MotorNode *);
    
    // 链表指针
    struct _MotorNode *next;
} MotorNode_t;

// 电机管理器（链表头）
typedef struct {
    MotorNode_t *head;        // 链表头
    uint8_t count;            // 电机数量
    uint8_t rm_tx_buffer[8];  // RM电机统一发送缓冲
} MotorManager_t;
```

### 1.3 链表操作API

```c
// 动态注册电机
MotorNode_t* Motor_Register(uint8_t id, uint8_t band);

// 根据ID查找电机
MotorNode_t* Motor_Find(uint8_t id);

// 根据品牌遍历
MotorNode_t* Motor_FindByBand(uint8_t band, MotorNode_t *start);

// 注销电机
void Motor_Unregister(uint8_t id);

// 遍历所有电机
#define MOTOR_FOREACH(node) \
    for(MotorNode_t *node = MotorManager.head; node != NULL; node = node->next)
```

### 1.4 使用示例

```c
// 注册电机
MotorNode_t *gripper = Motor_Register(1, RM_MOTOR_BAND);
gripper->pid_mode = 1;  // 串级
gripper->send = RM_MotorSendControl;
gripper->solve = RM_MOTOR_CALCU;

// 访问解算数据（两种方式）
float angle = gripper->solved.rm.angle;     // 方式1：按品牌访问
float angle = gripper->solved.data[0];      // 方式2：统一数组

// 遍历所有RM电机
MotorNode_t *node = Motor_FindByBand(RM_MOTOR_BAND, NULL);
while(node) {
    // 处理...
    node = Motor_FindByBand(RM_MOTOR_BAND, node->next);
}
```

---

## 二、HX06L 舵机数据帧优化

### 2.1 当前问题

```c
// 当前：使用普通数组手动组包
uint8_t data[16] = {0x00};
data[0] = 0x55;
data[1] = 0x55;
data[2] = ID;
data[3] = get_servo_data_length(...);
// ...
```

**缺点**：手动组包易出错，可读性差

### 2.2 优化方案：共用体数据帧

```c
#pragma pack(1)  // 1字节对齐

// 舵机指令帧结构（共用体）
typedef union {
    // 结构化访问
    struct {
        uint8_t header[2];    // 固定 0x55 0x55
        uint8_t id;           // 舵机ID
        uint8_t length;       // 数据长度
        uint8_t command;      // 指令
        union {
            // 位置时间指令参数
            struct {
                uint16_t angle;
                uint16_t time;
            } move_time;
            
            // ID设置参数
            struct {
                uint8_t new_id;
            } id_set;
            
            // 角度限制参数
            struct {
                uint16_t min_angle;
                uint16_t max_angle;
            } angle_limit;
            
            // 电压限制参数
            struct {
                uint16_t min_vin;
                uint16_t max_vin;
            } vin_limit;
            
            // 通用参数数组
            uint8_t params[8];
        };
        uint8_t checksum;     // CRC校验
    } frame;
    
    // 原始字节访问
    uint8_t raw[16];
} ServoPacket_t;

#pragma pack()

// 舵机反馈帧
typedef union {
    struct {
        uint8_t header[2];
        uint8_t id;
        uint8_t length;
        uint8_t command;
        union {
            int16_t position;   // 位置反馈
            uint16_t vin;       // 电压反馈
            uint8_t temp;       // 温度反馈
            uint8_t params[4];
        };
        uint8_t checksum;
    } frame;
    
    uint8_t raw[12];
} ServoResponse_t;
```

### 2.3 使用示例

```c
// 组包变得简单清晰
ServoPacket_t pkt = {0};
pkt.frame.header[0] = 0x55;
pkt.frame.header[1] = 0x55;
pkt.frame.id = servo_id;
pkt.frame.length = 7;
pkt.frame.command = SERVO_MOVE_TIME_WRITE;
pkt.frame.move_time.angle = 500;
pkt.frame.move_time.time = 1000;
pkt.frame.checksum = CalcCRC(pkt.raw + 2, pkt.frame.length);

// 发送
UART_Send(BSP_UART3, pkt.raw, pkt.frame.length + 3);

// 接收解析
ServoResponse_t resp;
memcpy(resp.raw, rx_buffer, sizeof(resp));
printf("Position: %d\n", resp.frame.position);
```

---

## 三、PID 控制器优化

### 3.1 当前问题

PID结构体包含很多字段，位置式和增量式共用同一结构但使用不同字段。

### 3.2 优化方案：共用体分离不同模式数据

```c
// PID核心参数（共享）
typedef struct {
    float kp, ki, kd, kf;
    float max_output;
    float max_iout;
} PID_Params_t;

// 模式特定数据（共用体）
typedef union {
    // 位置式PID特定数据
    struct {
        float sum_error;      // 积分累计
    } position;
    
    // 增量式PID特定数据
    struct {
        float prev_error;     // 上上次误差
        float last_output;    // 上次输出
    } incremental;
} PID_ModeData_t;

// 优化后的PID结构体
typedef struct {
    // 模式选择
    PID_MODE_e mode;
    uint8_t initialized;
    
    // 共享参数
    PID_Params_t params;
    
    // 实时数据
    float target;
    float measure;
    float last_measure;       // 微分先行用
    float error;
    float last_error;
    float output;
    
    // 模式特定数据
    PID_ModeData_t mode_data;
    
    // 前馈
    float feedforward;
    float last_target;
} PID_t;
```

---

## 四、整体架构优化建议

### 4.1 内存池管理（可选）

对于嵌入式系统，可使用静态内存池代替动态malloc：

```c
#define MAX_MOTORS 8

// 静态内存池
static MotorNode_t motor_pool[MAX_MOTORS];
static uint8_t motor_used[MAX_MOTORS] = {0};

// 从池中分配
MotorNode_t* Motor_Alloc(void) {
    for(int i = 0; i < MAX_MOTORS; i++) {
        if(!motor_used[i]) {
            motor_used[i] = 1;
            return &motor_pool[i];
        }
    }
    return NULL;  // 池满
}

// 释放回池
void Motor_Free(MotorNode_t *node) {
    int idx = node - motor_pool;
    if(idx >= 0 && idx < MAX_MOTORS) {
        motor_used[idx] = 0;
        memset(node, 0, sizeof(MotorNode_t));
    }
}
```

### 4.2 统一回调接口

```c
// 定义统一的电机操作接口
typedef struct {
    uint8_t (*send)(MotorNode_t *);           // 发送控制
    void (*solve)(MotorNode_t *, uint8_t *);  // 数据解算
    void (*enable)(MotorNode_t *);            // 使能
    void (*disable)(MotorNode_t *);           // 失能
} MotorOps_t;

// 不同品牌的操作实现
const MotorOps_t rm_motor_ops = {
    .send = RM_MotorSendControl,
    .solve = RM_MOTOR_CALCU,
    .enable = NULL,
    .disable = NULL,
};

const MotorOps_t dm_motor_ops = {
    .send = DM_MotorSendControl,
    .solve = DM_MOTOR_CALCU,
    .enable = DM_MotorEnable,
    .disable = DM_MotorDisable,
};
```

### 4.3 事件驱动（FreeRTOS）

```c
// 定义电机事件
typedef enum {
    MOTOR_EVT_DATA_READY = (1 << 0),  // 数据就绪
    MOTOR_EVT_ERROR      = (1 << 1),  // 错误
    MOTOR_EVT_TIMEOUT    = (1 << 2),  // 超时
} MotorEvent_t;

// 电机节点添加事件组
typedef struct _MotorNode {
    // ... 其他字段 ...
    EventGroupHandle_t events;  // FreeRTOS事件组
} MotorNode_t;
```

---

## 五、优化对比

| 方面 | 当前设计 | 优化后 |
|-----|---------|--------|
| 电机管理 | 静态数组，固定大小 | 链表，动态扩展 |
| 内存使用 | PID同时存在单环+串级 | 共用体，按需使用 |
| 数据组包 | 手动数组操作 | 结构化共用体 |
| 代码可读性 | `data[3] = xxx` | `pkt.frame.length = xxx` |
| 扩展性 | 需修改宏定义 | 运行时动态添加 |
| 类型安全 | 弱 | 强（编译器检查） |

---

## 六、实施建议

### 优先级建议

1. **高优先级**：HX06L 共用体优化（改动小，收益大）
2. **中优先级**：PID 共用体优化（节省内存）
3. **低优先级**：CanMotor 链表重构（改动大，需全面测试）

### 注意事项

1. 使用`#pragma pack(1)`确保结构体紧凑
2. 链表操作需考虑中断安全（加锁或原子操作）
3. 共用体访问时确保类型正确
4. 保持向后兼容的API

---

## 七、参考代码位置

- `User/inc/CanMotor.h` - 电机管理器定义
- `User/inc/HX06L.h` - 舵机协议定义
- `User/inc/PID.h` - PID控制器定义

---

**文档创建时间**: 2025/12/03  
**版本**: v1.0
